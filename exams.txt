2022.1 IDMa.1
A.
Person ⨯ Nat → Prop
Int → Prop
Person → Person
Int ⨯ Int ⨯ Int → Prop
Var → Cmd
Prop → Cmd
String ⨯ Nat → Prop
Type ⨯ Prop → Cmd
B.B1.
Sejam c, u, v: Int. --Dados: c, u, v: Int; Alvo: u + c = v + c ⇒ u = v
Suponha u + c = v + c. --Dados: u + c = v + c; Alvo: u = v
Logo (u + c) + (-c) = (v + c) + (-c)    [(+ (-c))]
Logo u + (c + (-c)) = v + (c + (-c))    [(+)-ass]
Logo u + 0 = v + 0    [((-)-invR-(+)) c]
Logo u = v    [(0-idR-(+))]
Imediato.
∎
C.C3.
Seja x: Int. --Dados: x: Int; Alvo: x · 0 = 0
Calculamos:
  x · 0 + 0
    = x · 0    [0-idR-(+)]
    = x · (0 + 0)   [0-idR-(+)]
    = (x · 0) + (x · 0)    [(·)-distL]
--Dados: (x · 0) + 0 = (x · 0) + (x · 0)
Logo 0 = x · 0. [((+)-canL) (x · 0)]    -- ou [(+)-resR]
Imediato.
∎

2022.2 IDMa.1
A.
Person ⨯ Lang → Prop
Var ⨯ Prop → Cmd
Prop → Cmd
Person
Prop ⨯ Int → Prop
Prop → Cmd
Type ⨯ Prop → Cmd
City ⨯ Nat → Prop
B.
¬(P ∧ Q) ⇒ ¬P ∨ ¬Q) ∨ (¬(P ∧ Q) ⇐ ¬P ∨ ¬Q)
Esc-R.
Suponha ¬P ∨ ¬Q.
Suponha P ∧ Q.
Ext-LR em P ∧ Q para obter P e Q.
Separo em casos a partir de ¬P ∨ ¬Q.
Caso-L:
  Aplico ¬P em P para obter ⊥.
  Contradição.
Caso-R:
  Aplico ¬Q em Q para obter ⊥.
  Contradição.
∎
C.
(∀a, u, v : Int)[a | u ∨ a | v ⇒ (∀x : Int)[a | (uv)x]]
Sejam a, u, v : Int.
Suponha h: a | u ∨ a | v.
Seja x : Int.
Separo em casos a partir de h.
Caso-L:
  Seja k₁ tal que u = ak₁.
  Calculamos:
    (uv)x
      ≡ ((ak₁)v)x
      = a((k₁v)x)   [(·)-ass]
  Escolho k = (k₁v)x.
  Imediato.
Caso-R:    -- poderia ser 'Similar.'?
  Seja k₁ tal que u = ak₁.
  Calculamos:
    (uv)x
      ≡ ((ak₂)v)x
      = a((k₂v)x)   [(·)-ass]
  Escolho k = (k₂v)x.
  Imediato.
∎

2023.2 IDMa.1
A.
Person → Prop
Person ⨯ Lang ⨯ Nat → Prop
Var ⨯ Prop → Prop
Type → Cmd
Prop → Cmd
Prop ⨯ Int ⨯ (Int → Prop) → Prop
Prop ⨯ Int → Prop
Type ⨯ Prop → Prop
B.
((P ∧ Q) ⇒ R) ⇒ ((P ⇒ Q) ⇒ R) ∨ (P ⇒ (Q ⇒ R))
Suponha h: (P ∧ Q) ⇒ R.
Esc-R.
Suponha P.
Suponha Q.
Vou demonstrar P ∧ Q:
  Split.
  Parte-L:
    Imediato em P.
  Parte-R:
    Imediato em Q.
Aplico h em P ∧ Q para obter R.
Imediato.
∎
C.C1.
(∀a)[(-1)a = -a]
Seja a : Int.
Calculamos:
  a + (-1)a
    = (1 · a) + (-1)a   [(1-idL-(·)) a]
    = (1 + (-1)) · a    [(+)-distR-(·)]
    = 0 · a             [((-)-invR-(+)) 1]
    = 0                 [0-annL-(·)]
  a + (-a)
    = 0                 [(-)-invR-(+)]
Logo (-1)a = -a.        [((+)-canL) a]    -- ou [(+)-resR]
Imediato.
∎

2024.2 IDMa.1
A.
Prop → Cmd
Prop ⨯ (Int ⨯ Int → Int) ⨯ (Int → Prop) → Prop
Person ⨯ Nat → Prop
Person ⨯ City ⨯ Nat → Prop
Var ⨯ Type ⨯ Prop → Prop
Type → Cmd
Prop ⨯ Person → Prop
Type ⨯ Int ⨯ Int → Prop
B.B1.
¬P ∨ ¬Q ⇒ ¬(P ∧ Q)
Suponha ¬P ∨ ¬Q.
Suponha P ∧ Q.
Ext-LR em P ∧ Q para obter P e Q.
Separo em casos a partir de ¬P ∨ ¬Q.
Caso-L:
  Aplico ¬P em P para obter ⊥.
  Contradição.
Caso-R:
  Aplico ¬Q em Q para obter ⊥.
  Contradição.
∎
C.C3.
(∀a, b)[ab = 0 ⇒ a = 0 ∨ b = 0]
Sejam a, b : Int.
Suponha ab = 0.
LEM[b].
Separo em casos a partir de b = 0 ∨ b ≠ 0.
Caso-L:
  Esc-R.
  Imediato.
Caso-R:
  Esc-L.
  Logo 0b = 0.   [0-annL-(·)]
  Logo ab = 0b.    -- poderia ser "Como... logo..."?
  Como b ≠ 0, logo a = 0.    [(·)-canR]
  Imediato.
∎⛦
