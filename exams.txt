2022.1 IDMa.1
A.
Person ⨯ Nat → Prop
Int → Prop
Person → Person
Int ⨯ Int ⨯ Int → Prop
Var → Cmd
Prop → Cmd
String ⨯ Nat → Prop
Type ⨯ Prop → Cmd
B.B1.
Sejam c, u, v: Int. --Dados: c, u, v: Int; Alvo: u + c = v + c ⇒ u = v
Suponha u + c = v + c. --Dados: u + c = v + c; Alvo: u = v
Logo (u + c) + (-c) = (v + c) + (-c)    [(+ (-c))]
Logo u + (c + (-c)) = v + (c + (-c))    [(+)-ass]
Logo u + 0 = v + 0    [((-)-invR-(+)) c]
Logo u = v    [(0-idR-(+))]
Imediato.
∎
C.C3.
Seja x: Int. --Dados: x: Int; Alvo: x · 0 = 0
Calculamos:
  x · 0 + 0
    = x · 0    [0-idR-(+)]
    = x · (0 + 0)   [0-idR-(+)]
    = (x · 0) + (x · 0)    [(·)-distL]
--Dados: (x · 0) + 0 = (x · 0) + (x · 0)
Logo 0 = x · 0. [((+)-canL) (x · 0)]    -- ou [(+)-resR]
Imediato.
∎

2022.2 IDMa.1
A.
Person ⨯ Lang → Prop
Var ⨯ Prop → Cmd
Prop → Cmd
Person
Prop ⨯ Int → Prop
Prop → Cmd
Type ⨯ Prop → Cmd
City ⨯ Nat → Prop
B.
¬(P ∧ Q) ⇒ ¬P ∨ ¬Q) ∨ (¬(P ∧ Q) ⇐ ¬P ∨ ¬Q)
Esc-R.
Suponha ¬P ∨ ¬Q.
Suponha P ∧ Q.
Ext-LR em P ∧ Q para obter P e Q.
Separo em casos a partir de ¬P ∨ ¬Q.
Caso-L:
  Aplico ¬P em P para obter ⊥.
  Contradição.
Caso-R:
  Aplico ¬Q em Q para obter ⊥.
  Contradição.
∎
C.
(∀a, u, v : Int)[a | u ∨ a | v ⇒ (∀x : Int)[a | (uv)x]]
Sejam a, u, v : Int.
Suponha h: a | u ∨ a | v.
Seja x : Int.
Separo em casos a partir de h.
Caso-L:
  Seja k₁ tal que u = ak₁.
  Calculamos:
    (uv)x
      ≡ ((ak₁)v)x
      = a((k₁v)x)   [(·)-ass]
  Escolho k = (k₁v)x.
  Imediato.
Caso-R:    -- poderia ser 'Similar.'?
  Seja k₁ tal que u = ak₁.
  Calculamos:
    (uv)x
      ≡ ((ak₂)v)x
      = a((k₂v)x)   [(·)-ass]
  Escolho k = (k₂v)x.
  Imediato.
∎

2023.2 IDMa.1
A.
Person → Prop
Person ⨯ Lang ⨯ Nat → Prop
Var ⨯ Prop → Prop
Type → Cmd
Prop → Cmd
Prop ⨯ Int ⨯ (Int → Prop) → Prop
Prop ⨯ Int → Prop
Type ⨯ Prop → Prop
B.
((P ∧ Q) ⇒ R) ⇒ ((P ⇒ Q) ⇒ R) ∨ (P ⇒ (Q ⇒ R))
Suponha h: (P ∧ Q) ⇒ R.
Esc-R.
Suponha P.
Suponha Q.
Vou demonstrar P ∧ Q:
  Split.
  Parte-L:
    Imediato em P.
  Parte-R:
    Imediato em Q.
Aplico h em P ∧ Q para obter R.
Imediato.
∎
C.C1.
(∀a)[(-1)a = -a]
Seja a : Int.
Calculamos:
  a + (-1)a
    = (1 · a) + (-1)a   [(1-idL-(·)) a]
    = (1 + (-1)) · a    [(+)-distR-(·)]
    = 0 · a             [((-)-invR-(+)) 1]
    = 0                 [0-annL-(·)]
  a + (-a)
    = 0                 [(-)-invR-(+)]
Logo (-1)a = -a.        [((+)-canL) a]    -- ou [(+)-resR]
Imediato.
∎

2024.2 IDMa.1
A.
Prop → Cmd
Prop ⨯ (Int ⨯ Int → Int) ⨯ (Int → Prop) → Prop
Person ⨯ Nat → Prop
Person ⨯ City ⨯ Nat → Prop
Var ⨯ Type ⨯ Prop → Prop
Type → Cmd
Prop ⨯ Person → Prop
Type ⨯ Int ⨯ Int → Prop
B.B1.
¬P ∨ ¬Q ⇒ ¬(P ∧ Q)
Suponha ¬P ∨ ¬Q.
Suponha P ∧ Q.
Ext-LR em P ∧ Q para obter P e Q.
Separo em casos a partir de ¬P ∨ ¬Q.
Caso-L:
  Aplico ¬P em P para obter ⊥.
  Contradição.
Caso-R:
  Aplico ¬Q em Q para obter ⊥.
  Contradição.
∎
C.C3.
(∀a, b)[ab = 0 ⇒ a = 0 ∨ b = 0]
Sejam a, b : Int.
Suponha ab = 0.
LEM[b].
Separo em casos a partir de b = 0 ∨ b ≠ 0.
Caso-L:
  Esc-R.
  Imediato.
Caso-R:
  Esc-L.
  Logo 0b = 0.   [0-annL-(·)]
  Logo ab = 0b.    -- poderia ser "Como... logo..."?
  Como b ≠ 0, logo a = 0.    [(·)-canR]
  Imediato.
∎⛦

2023.2 IRI.1
D.
compare : Nat → Nat → Nat
compare O O = O
compare O (S n) = 1
compare (S n) O = 2
compare (S n) (S m) = compare n m
E.
(∀a, b, u)[compare a b = compare (a + u) (b + u)]
Sejam a, b : Int.
Por indução.
Base:
  Calculamos:
    compare (a + 0) (b + 0)
      = compare a (b + 0)   [(+).1]
      = compare a b         [(+).1]
Passo indutivo:
  Seja k tal que compare a b = compare (a + k) (b + k).
  Calculamos:
    compare (a + Sk) (b + Sk)
      = compare S(a + k) S(b + k)   [(+).2]
      = compare (a + k) (b + k)     [(compare).4]
      = compare a b                 [H.I.]
∎

2023.2 IRI.3
L.L1.
length (xs ++ ys) = length xs + length ys
map f ○ map g = map (f ○ g)
map f (xs ++ ys) = map f xs ++ map f ys
map id = id
filter p ○ map f = map f ○ filter (p ○ f)
product ○ map (n ^) = (n ^) ○ sum
L2.
length : (Integral i) ⇒ List α → i
length [] = 0
length (x : xs) = 1 + length xs
map : (α → β) → List α → List β
map f [] = []
map f (x : xs) = f x : (map f xs)
filter : (α → Bool) → List α → List α
filter _ [] = []
filter p (x : xs)
  | p x = x : filter p xs
  | otherwise = filter p xs
foldr : (a → b → b) → b → [a] → b
foldr f u [] = u
foldr f u (x : xs) = f x (foldr f u xs)
L3.
length (xs ++ ys) = length xs + length ys
Por indução.
Base:
  Seja ys : List α.
  Calculamos:
    length ([] ++ ys)
      = length ys      [(++).1]
    length [] + length ys
      = 0 + length ys  [(length).1]
      = length ys      [(+).1]
Passo indutivo:
  Sejam xs, ys : List α.
  Suponha que length (xs ++ ys) = length xs + length ys.
  Calculamos:
    length ((x : xs) ++ ys)
      = length (x : (xs ++ ys))    [(++).2]
      = 1 + length (xs ++ ys)      [(length).2]
      = 1 + length xs + length ys  [H.I.]
    length (x : xs) + length ys
      = (1 + length xs) + length ys  [(length).2]
      = 1 + length xs + length ys    [(+)-assoc]
∎

2024.2 IRI.1
A.
data Nat = O | S Nat
data List a where
  Nil  : List a
  Cons : a → List a → List a
map : (α → β) → List α → List β
map f [] = []
map f (x :: xs) = f x : (map f xs)
filter : (α → Bool) → List α → List α
filter _ [] = []
filter p (x : xs)
  | p x = x : filter p xs
  | otherwise = filter p xs
pwAdd : Num α ⇒ List α → List α → List α
pwAdd xs ys = zipWith (+) xs ys
foldr : (a → b → b) → b → [a] → b
foldr f u [] = u
foldr f u (x : xs) = f x (foldr f u xs)
G.
map f (xs ++ ys) = (map f xs) ++ (map f ys)
sum (xs ++ ys) = sum xs + sum ys
product (xs ++ ys) = product xs * product ys
length (xs ++ ys) = length xs + length ys
reverse (xs ++ ys) = reverse ys ++ reverse xs
length (map f xs) = length xs
sum (replicate n x) = n * x
sum (map (+ k) ns) = sum ns + (length ns * k)
sum (map (* k) ns) = sum ns * k
product (map (* k) ns) = product ns * (k ^ length ns)
P.
map f (xs ++ ys) = (map f xs) ++ (map f ys)
Sejam xs, ys : List α.
Por indução em xs.
Caso xs = []:
  Calculamos:
    map f ([] ++ ys)
      = map f ys    [(++).1]
    (map f []) ++ (map f ys)
      = [] ++ (map f ys)    [(map).1]
      = map f ys            [(++).1]
Caso xs = (x : xs):
  Suponha que map f (xs ++ ys) = (map f xs) ++ (map f ys).
  Calculamos:
    map f ((x : xs) ++ ys)
      = map f (x : (xs ++ ys))          [(++).2]
      = f x : map f (xs ++ ys)          [(map).2]
      = f x : (map f xs) ++ (map f ys)  [H.I.]
    (map f (x : xs)) ++ (map f ys)
      = (f x : map f xs) ++ (map f ys)  [(map).2]
      = f x : (map f xs) ++ (map f ys)  [(++).2]
∎
length (map f xs) = length xs
Por indução.
Base:
  Calculamos:
    length (map f [])
      = length []    [(map).1]
Passo indutivo:
  Suponha length (map f xs) = length xs.
  Calculamos:
    length (map f (x : xs))
      = length (f x : map f xs)    [(map).2]
      = 1 + length (map f xs)      [(length).2]
      = 1 + length xs              [H.I.]
    length (x : xs)
      = 1 + length xs              [(length).2]
∎
length : (Integral i) ⇒ List α → i
length [] = 0
length (x : xs) = 1 + length xs
