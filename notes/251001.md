## IRI
- ProgramaÃ§Ã£o imperativa vs. declarativa
- Forma geral da induÃ§Ã£o
- os construtores preservam Ï†
      `(âˆ€x : Î±)[Ï†(x)]`
  ind Ï† Î±
  Ï† : Î± â†’ Prop
- l : LÎ±
Por induÃ§Ã£o no l.
Caso []:
  |
Caso (x : xs):
  |
- Î²
Câ‚ : Î²
Câ‚‚ : Î² â†’ Nat â†’ Î² â†’ String â†’ Î²
Câ‚ƒ : Î² â†’ Î² â†’ Î²
Câ‚„ : Nat â†’ Nat â†’ Î²

`(âˆ€b : Î²)[Ï†(b)]`
Seja b : Î².
InduÃ§Ã£o no b.
Caso Câ‚:
  | -- âŠ¢ Ï†(Câ‚) -- sem HI
Caso (Câ‚‚ b' n b" s):
  | -- b', b" : Î², n : Nat, s : String, HIs: Ï†(b'), Ï†(b") âŠ¢ Ï†(Câ‚‚ b' n b" s)
Caso (Câ‚ƒ bâ‚ bâ‚‚ bâ‚ƒ):
  | -- b_x : Î², HIs: Ï†(bâ‚), Ï†(bâ‚‚), Ï†(bâ‚ƒ) âŠ¢ Ï†(Câ‚ƒ bâ‚ bâ‚‚ bâ‚ƒ)
Caso (Câ‚„ n m):
  | -- n, m : Nat âŠ¢ Ï†(Câ‚„ n m) -- sem HI

`(âˆ€b : Bool)[Ï†(b)]`
Seja b : Bool.
InduÃ§Ã£o no b.
Caso ğ˜§ğ˜§:
  |  -- âŠ¢ Ï†(ğ˜§ğ˜§)
Caso ğ˜µğ˜µ:
  |  -- âŠ¢ Ï†(ğ˜µğ˜µ)

- Construtores distintos constroem habitantes distintos
- Um construtor, recebendo argumentos distintos, constrÃ³i habitantes distintos (injetividade)
- f u = f v â‡’ u = v
  u â‰  v â‡’ f u â‰  f v
  (f preserva distinÃ§Ãµes)
- Hs: `deriving Eq`
- congruÃªncia da igualdade
- map :: (Î± â†’ Î²) â†’ ([Î±] â†’ [Î²])
  map f - unÃ¡ria
- filter
- fold -- feito

## IDMa
- min & max
    min : Set Int â‡€ Int
    m = min A : Prop
    - Sejam m : Int, A : Set Int
      m Ã© um mÃ­nimo de A â‡â‰â‡’ `m âˆˆ A âˆ§ (âˆ€x âˆˆ A)[m â‰¤ x]`
    max : Set Int â‡€ Int
    m = max A : Prop
    - Sejam m : Int, A : Set Int
      m Ã© um mÃ¡ximo de A â‡â‰â‡’ `m âˆˆ A âˆ§ (âˆ€x âˆˆ A)[x â‰¤ m]`
    - refazer unicd -- feito
      (âˆ€A)(âˆ€u, v)[u, v mÃ­nima de A â‡’ u = v]
- relaÃ§Ã£o prÃ©-ordem de divide (|)
  min Int = Â±1
  max Int = 0
- comdiv (12, 18)

