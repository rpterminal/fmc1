## IRI
- Programação imperativa vs. declarativa
- Forma geral da indução
- os construtores preservam φ
      `(∀x : α)[φ(x)]`
  ind φ α
  φ : α → Prop
- l : Lα
Por indução no l.
Caso []:
  |
Caso (x : xs):
  |
- β
C₁ : β
C₂ : β → Nat → β → String → β
C₃ : β → β → β
C₄ : Nat → Nat → β

`(∀b : β)[φ(b)]`
Seja b : β.
Indução no b.
Caso C₁:
  | -- ⊢ φ(C₁) -- sem HI
Caso (C₂ b' n b" s):
  | -- b', b" : β, n : Nat, s : String, HIs: φ(b'), φ(b") ⊢ φ(C₂ b' n b" s)
Caso (C₃ b₁ b₂ b₃):
  | -- b_x : β, HIs: φ(b₁), φ(b₂), φ(b₃) ⊢ φ(C₃ b₁ b₂ b₃)
Caso (C₄ n m):
  | -- n, m : Nat ⊢ φ(C₄ n m) -- sem HI

`(∀b : Bool)[φ(b)]`
Seja b : Bool.
Indução no b.
Caso 𝘧𝘧:
  |  -- ⊢ φ(𝘧𝘧)
Caso 𝘵𝘵:
  |  -- ⊢ φ(𝘵𝘵)

- Construtores distintos constroem habitantes distintos
- Um construtor, recebendo argumentos distintos, constrói habitantes distintos (injetividade)
- f u = f v ⇒ u = v
  u ≠ v ⇒ f u ≠ f v
  (f preserva distinções)
- Hs: `deriving Eq`
- congruência da igualdade
- map :: (α → β) → ([α] → [β])
  map f - unária
- filter
- fold -- feito

## IDMa
- min & max
    min : Set Int ⇀ Int
    m = min A : Prop
    - Sejam m : Int, A : Set Int
      m é um mínimo de A ⇐≝⇒ `m ∈ A ∧ (∀x ∈ A)[m ≤ x]`
    max : Set Int ⇀ Int
    m = max A : Prop
    - Sejam m : Int, A : Set Int
      m é um máximo de A ⇐≝⇒ `m ∈ A ∧ (∀x ∈ A)[x ≤ m]`
    - refazer unicd -- feito
      (∀A)(∀u, v)[u, v mínima de A ⇒ u = v]
- relação pré-ordem de divide (|)
  min Int = ±1
  max Int = 0
- comdiv (12, 18)

