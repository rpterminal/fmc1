Θ. (+)-canR ⇐⇒ (∀c)(∀x, y)[x + c = y + c ⇒ x = y]
Sejam c, u, v: Int. --Dados: c, u, v: Int; Alvo: u + c = v + c ⇒ u = v
Suponha u + c = v + c. --Dados: u + c = v + c; Alvo: u = v
Logo (u + c) + (-c) = (v + c) + (-c)    [(+ (-c))]
Logo u + (c + (-c)) = v + (c + (-c))    [(+)-ass]
Logo u + 0 = v + 0    [((-)-invR-(+)) c]
Logo u = v    [(0-idR-(+))]
Imediato.
∎
Θ. (+)-canL ⇐⇒ (∀c)(∀x, y)[c + x = c + y ⇒ x = y]
Sejam c, u, v: Int. --Dados: c, u, v: Int; Alvo: c + u = c + v ⇒ u = v
Suponha c + u = c + v. --Dados: c + u = c + v; Alvo: u = v
Logo u + c = v + c.   [((+)-com) c u; ((+)-com) c v]
Logo u = v.   [(+)-canR]
Imediato.
∎

Θ. 0-annR-(·) ⇐⇒ (∀x)[x · 0 = 0]
Seja x: Int. --Dados: x: Int; Alvo: x · 0 = 0
Calculamos:
  x · 0 + 0
    = x · 0    [0-idR-(+)]
    = x · (0 + 0)   [0-idR-(+)]
    = (x · 0) + (x · 0)    [(·)-distL]
--Dados: (x · 0) + 0 = (x · 0) + (x · 0)
Logo 0 = x · 0. [((+)-canL) (x · 0)]
Imediato.
∎
Θ. 0-annL-(·) ⇐⇒ (∀x)[0 · x = 0]
Seja x: Int. --Dados: x: Int; Alvo: 0 · x = 0
Calculamos:
  0 · x
    = x · 0   [(·)-com]
    = 0   [0-annR-(·)]
∎

e.u.d.: ≡ᷤ (P ∧ ¬Q ∧ ¬R) ∨ (Q ∧ ¬P ∧ ¬R) ∨ (R ∧ ¬P ∧ ¬Q)

Θ. (∀a ≠ 0)[a² positivo]
Seja a ≠ 0.
Sep casos [(tri) a].
Caso a pos.
  Logo a · a pos.    [(Pos-(·)-Cl) a a]
Caso a = 0.
  Impossível.
Caso -a pos.
  Logo (-a) · (-a) pos.    [(Pos-(·)-Cl) -a -a]

Θ. (∀A)(∀u, v)[u, v min de A ⇒ u = v]
Seja A : Set Int.
Sejam u, v : Int.
Suponha h: u, v min de A.
Ext-LR em h para obter h₁ e h₂.
Logo u ≤ v.
Logo v ≤ u.
Logo u = v.    [(≤)-antisym]
Imediato.
∎

Θ. (≤)-antisym ⇐⇒ (∀a, b)[a ≤ b ∧ b ≤ a ⇒ a = b]
Sejam a, b.
Suponha h: a ≤ b ∧ b ≤ a.
Ext-LR em h para obter h₁ e h₂.
Suponha, por contradição, que a ≠ b.
Separo em casos a partir de ZO-Tri.
Caso a < b:
  Contradição em a < b e b ≤ a.
Caso b < a:
  Contradição em b < a e a ≤ b.
∎
